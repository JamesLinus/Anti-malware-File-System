/*****************************************************************
* File name     : amfsctl.c
* Date created  : Sep 16, 2015
* Author name   : Vishal Sahu
* Email         : vsahu@cs.stonybrook.edu
* Organization  : Computer Science department, Stony Brook University
* Description:  : User level interface to add/remove/list pattern
				  database
******************************************************************/

#include <asm/unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>

#include <string.h>
#include <sys/ioctl.h>
#include <fcntl.h>

#include "ioctl_labels.h"
#define PATTERN_LEN 128

int main(int argc, char * const argv[])
{
	int fd;
	FILE *ofp = NULL;
	extern int optind;
	extern char *optarg;
	int opt, err, add = 0, rem = 0, show_patterns = 0;
	char *add_pattern = NULL;
	char *remove_pattern = NULL;
	char *mount_point = NULL;

	char list_pattern[20] = "bufferholder.txt";

	char *line = NULL;
	size_t len = 0;
	ssize_t read;

	while ((opt = getopt(argc, argv, "l:a:r:h")) != -1) {
		switch (opt) {
		case 'l':
			show_patterns = 1;
			break;
		case 'a':
			add = 1;
			add_pattern = optarg;
			break;
		case 'r':
			rem = 1;
			remove_pattern = optarg;
			break;
		case 'h':
			printf("Usage: %s -l -a 'add_this' -r 'remove_this' mount_point\n"
				, argv[0]);
			printf("-l: list existing pattern\n");
			printf("-a: adds passed pattern(max length = 128)\n");
			printf("-r: removes passed pattern\n");
			exit(0);
			break;
		default: /* '?' */
			printf("invalid set of argument(s) received.\n");
			printf("Use %s -h for synopsis\n", argv[0]);
			exit(0);
		}
	}

	if (optind  < 2) {
		printf("insufficient argument(s) received.\n");
		printf("Use %s -h for synopsis\n", argv[0]);
		exit(0);
	}

	if (argc - optind <= 1)
		mount_point = argv[argc-1];
	else {
		printf("invalid argument(s) received.\n");
		printf("Use %s -h for synopsis\n", argv[0]);
		exit(0);
	}

	fd = open((const char *)mount_point, O_RDONLY, 0);
	if (fd == -1) {
		perror("Unable to allocate file descriptor\n");
		return 2;
	}

	if (add == 1) {
		err = ioctl(fd, ADD, add_pattern);
		if (err == -1)
			exit(0);
	}
	if (rem == 1) {
		err = ioctl(fd, REM, remove_pattern);
		if (err == -1)
			exit(0);
	}
	if (show_patterns == 1) {
		err = ioctl(fd, LIST, list_pattern);
		if (err == -1)
			exit(0);
	    ofp = fopen(list_pattern, "r");
	    if (ofp == NULL)
			exit(EXIT_FAILURE);

	    while ((read = getline(&line, &len, ofp)) != -1)
	    	printf("%s", line);
	    free(line);
	    fclose(ofp);
	    err = remove((const char *)list_pattern);
	}
	exit(0);
}
