/*
 * Copyright (c) 1998-2014 Erez Zadok
 * Copyright (c) 2009	   Shrikar Archak
 * Copyright (c) 2015	   Vishal Sahu
 * Copyright (c) 2003-2014 Stony Brook University
 * Copyright (c) 2003-2014 The Research Foundation of SUNY
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#include "amfs.h"

/*This list contains information about Quarintine files*/
static LIST_HEAD(bad_files_list);

#ifdef EXTRA_CREDIT
static char *end_overlap;
static char *start_overlap;
static char *overlap;
#endif

static ssize_t amfs_read(struct file *file, char __user *buf,
			   size_t count, loff_t *ppos)
{
	int err;
	struct file *lower_file;
	struct dentry *dentry = file->f_path.dentry;
	struct amfs_sb_info *sbi = (struct amfs_sb_info *)
	dentry->d_inode->i_sb->s_fs_info;
	struct list_head *plist_head = sbi->pattern_list_head;

	struct pattern_item *temp_node = NULL;
	struct list_head *pos = NULL;
	char *temp_char = NULL;
	int lerr;
	struct bad_file_item *bad_item = NULL;

	char *ATTR = NULL;

	ATTR = (char *) kzalloc(sizeof(char)*4, GFP_KERNEL);
	if (!ATTR) {
		err = -ENOMEM;
		goto out;
	}

	lerr = dentry->d_inode->i_op->getxattr(dentry, STAT, ATTR, 4);
	if (lerr < 0) {
		goto PASS;
	}

	if (strcmp(ATTR, "BAD") == 0) {
		err = -EPERM;
		goto out;
	}

PASS:
	lower_file = amfs_lower_file(file);
	err = vfs_read(lower_file, buf, count, ppos);

	/* update our inode atime upon a successful lower read */
	if (err >= 0)
		fsstack_copy_attr_atime(dentry->d_inode,
					file_inode(lower_file));
#ifdef EXTRA_CREDIT

	if (err == count && end_overlap == NULL) {
		//printk("First time allocation\n");
		start_overlap = (char *) kzalloc
		(BOUNDARY_LEN*sizeof(char), GFP_KERNEL);
		if (!start_overlap) {
			err = -ENOMEM;
			goto out;
		}
		end_overlap = (char *) kzalloc(BOUNDARY_LEN*sizeof(char), GFP_KERNEL);
		if (!end_overlap) {
			err = -ENOMEM;
			goto out;
		}

		if (!strncpy(end_overlap, (const char *)
			(buf + err - BOUNDARY_LEN), BOUNDARY_LEN)) {
			err = -EFAULT;
			goto out;
		}
	}

	overlap = (char *) kzalloc(2*BOUNDARY_LEN*sizeof(char), GFP_KERNEL);
	if (!overlap) {
		err = -ENOMEM;
		goto out;
	}

	if (err >= BOUNDARY_LEN && end_overlap != NULL) {
		if (!strncpy(start_overlap, (const char *)buf, BOUNDARY_LEN)) {
			err = -EFAULT;
			goto out;
		}
		strncpy(overlap, end_overlap, BOUNDARY_LEN);
		strncat(overlap, start_overlap, BOUNDARY_LEN);
	}
#endif

	list_for_each(pos, plist_head)
	{
	    temp_node = list_entry(pos, struct pattern_item, list);
	    temp_char = strstr((const char *) buf, (const char *)
	     temp_node->pattern_data);
	    if (temp_char) {
			goto quarantine;
	    }
#ifdef EXTRA_CREDIT

		if (overlap != NULL) {
			temp_char = strstr((const char *) overlap, 
				(const char *) temp_node->pattern_data);
		    if (temp_char) {
		    	goto quarantine;
		    }
		}
#endif
	}

	lerr = dentry->d_inode->i_op->setxattr (dentry, STAT, "GOOD", 4, 0);
	if (lerr != 0) {
		err = -EPERM;
		goto out;
	}

#ifdef EXTRA_CREDIT
	/*buffering last part of current buffer for next iteration*/
	if (err == count) {
		if (!strncpy(end_overlap, (const char *)(buf + err - BOUNDARY_LEN),
		 BOUNDARY_LEN)) {
			err = -EFAULT;
			goto out;
		}
	}
#endif
	goto out;

quarantine:
	bad_item = (struct bad_file_item *)kmalloc(sizeof(struct bad_file_item),
	 GFP_KERNEL);
	if (!bad_item) { 
		err = -ENOMEM; 
		goto out;
	}

	bad_item->evicting_pattern = (char *)kmalloc(
		sizeof(temp_node->pattern_data), GFP_KERNEL);
	if (!bad_item->evicting_pattern) { // error check for kmalloc
		err = -ENOMEM; // out of memory
		goto out;
	}

	strcpy(bad_item->evicting_pattern, (const char *)temp_node->pattern_data);
	bad_item->bad_dentry = dentry;
	//printk("%s, %x\n", bad_item->evicting_pattern, bad_item->bad_dentry);
	list_add(&(bad_item->list), &bad_files_list);

	//free_dentry_private_data(dentry);

	lerr = dentry->d_inode->i_op->setxattr(dentry, STAT, "BAD", 3, 0);
	if (lerr != 0) {
		err = -EPERM;
		goto out;
	}
	err = -EPERM;

out:
	if (ATTR) 
		kfree(ATTR);

#ifdef EXTRA_CREDIT
	if (err == 0) {
		//printk("came to free overlap stuff\n");
		if (start_overlap) {
			kfree(start_overlap);
			start_overlap = NULL;
		}
		if (end_overlap) {
			kfree(end_overlap);
			end_overlap = NULL;
		}
	}
	if (overlap) {
		kfree(overlap);
		overlap = NULL;
	}
#endif
	return err;
}

static ssize_t amfs_write(struct file *file, const char __user *buf,
			    size_t count, loff_t *ppos)
{
	int err;
	struct file *lower_file;
	struct dentry *dentry = file->f_path.dentry;
	struct amfs_sb_info *sbi =(struct amfs_sb_info *)
	dentry->d_inode->i_sb->s_fs_info;
	struct list_head *plist_head = sbi->pattern_list_head;
	struct pattern_item *temp_node = NULL;
	struct list_head *pos = NULL;

	char *temp_char = NULL;
 	
	list_for_each(pos, plist_head)
	{
	    temp_node = list_entry(pos, struct pattern_item, list);
	    temp_char = strstr((const char *) buf, (const char *) 
	    	temp_node->pattern_data);
	    if (temp_char) {
	    	err = -EPERM;
	    	goto out;
	    }
	}

	lower_file = amfs_lower_file(file);
	err = vfs_write(lower_file, buf, count, ppos);
	/* update our inode times+sizes upon a successful lower write */
	if (err >= 0) {
		fsstack_copy_inode_size(dentry->d_inode,
					file_inode(lower_file));
		fsstack_copy_attr_times(dentry->d_inode,
					file_inode(lower_file));
	}
out:
	return err;
}


/* Below 2 methods adopted from ecryptfs with permission of Owner */

struct amfs_getdents_callback {
	struct dir_context ctx;
	struct dir_context *caller;
	struct super_block *sb;
	int filldir_called;
	int entries_written;
};

static int
amfs_filldir(struct dir_context *ctx, const char *lower_name,
		 int lower_namelen, loff_t offset, u64 ino, unsigned int d_type) 
{
	struct bad_file_item *temp_node = NULL;
	struct list_head *pos = NULL;

	struct amfs_getdents_callback *buf =
		container_of(ctx, struct amfs_getdents_callback, ctx);
	int rc;

	buf->filldir_called++;
	
	list_for_each(pos, &bad_files_list)
	{
	    temp_node = list_entry(pos, struct bad_file_item, list);
	    //TBD check for strcmp
	    //printk("%s, %s\n", temp_node->bad_dentry->d_iname, lower_name);
	    //if (strstr(temp_node->bad_dentry->d_iname, lower_name) != NULL) {
	    if (strcmp(temp_node->bad_dentry->d_iname, lower_name) == 0) {
	    	return 0;
	    }
	}

	buf->caller->pos = buf->ctx.pos;
	// bypassing encryption, hence using lower name and length directly
	rc = !dir_emit(buf->caller, lower_name, lower_namelen, ino, d_type);
	if (!rc)
		buf->entries_written++;
	return rc;
}

static int amfs_readdir(struct file *file, struct dir_context *ctx)
{
	int err;
	struct file *lower_file = NULL;
	struct dentry *dentry = file->f_path.dentry;

	struct amfs_getdents_callback buf = {
		.ctx.actor = amfs_filldir,
		.caller = ctx,
		.sb = dentry->d_inode->i_sb,
	};

	lower_file = amfs_lower_file(file);
	// changing context of newly created struct buf
	err = iterate_dir(lower_file, &buf.ctx);
	file->f_pos = lower_file->f_pos;
	if (err >= 0)		/* copy the atime */
		fsstack_copy_attr_atime(dentry->d_inode,
					file_inode(lower_file));
	return err;
}

static long amfs_unlocked_ioctl(struct file *file, unsigned int cmd,
				  unsigned long arg)
{
	mm_segment_t oldfs;
	long err = -ENOTTY;
	struct file *lower_file;

	struct dentry *dentry = file->f_path.dentry;
	struct pattern_item *temp_node = NULL;
	struct list_head *pos = NULL;
	struct list_head *q = NULL;

	struct amfs_sb_info *sbi = (struct amfs_sb_info *)
	dentry->d_inode->i_sb->s_fs_info;
	struct list_head *plist_head = sbi->pattern_list_head;
	
	struct file *dest_file = NULL;
	struct file *ofp = NULL;

	struct pattern_item *new_pattern_item = NULL;
	char *pattern = NULL;
	char *list_to_dbfile = NULL;
	int ret = 0;
	int pattern_exists;

	struct bad_file_item *bad_f_item = NULL;
	struct list_head *iter = NULL;
	struct list_head *qq = NULL;
	int lerr;

	lower_file = amfs_lower_file(file);

	/* XXX: use vfs_ioctl if/when VFS exports it */
	if (!lower_file || !lower_file->f_op)
		goto out;
	if (lower_file->f_op->unlocked_ioctl)
		err = lower_file->f_op->unlocked_ioctl(lower_file, cmd, arg);

	/* some ioctls can change inode attributes (EXT2_IOC_SETFLAGS) */
	if (!err)
		fsstack_copy_attr_all(file_inode(file),
				      file_inode(lower_file));


	pattern = (char *)kzalloc(PATTERN_LEN, GFP_KERNEL);
	if (!pattern) {
		ret = -ENOMEM;
		goto out;
	}

	ret = copy_from_user(pattern, (const void __user *)arg, 
		strlen((char *)arg));
	if (ret > 0) {
		ret = -EFAULT;
		goto out;
	}

	list_to_dbfile = (char *)kzalloc(PATTERN_LEN, GFP_KERNEL);
	if (!list_to_dbfile) {
		ret = -ENOMEM;
		goto out;
	}

	switch(cmd) {
			
/************************************************
 * add pattern section
 ***********************************************/
		case ADD:
			// compare if exists
			list_for_each(pos, plist_head) {
				
			    temp_node = list_entry(pos, struct pattern_item, list);
			    ret = strcmp(pattern, temp_node->pattern_data);
			    //printk("%s %s %d\n", pattern, temp_node->pattern_data, ret);
			    
			    if (ret == 0) {
			    	ret = -EINVAL;
			    	goto out;
			    }
			}

			new_pattern_item = (struct pattern_item *)
			kzalloc(sizeof(struct pattern_item), GFP_KERNEL);
			if (!new_pattern_item) { // error check for kmalloc
				ret = -ENOMEM; // out of memory
				goto out;
			}
			strcpy(new_pattern_item->pattern_data, (const char *)pattern);
			list_add(&(new_pattern_item->list), plist_head);

			strcat(pattern, "\n\0");

			oldfs = get_fs();
    		set_fs(KERNEL_DS);
			
			dest_file = filp_open(sbi->pattern_db_name, O_APPEND, 0);   
			if (IS_ERR((void *)dest_file)) {
				ret = -EPERM;
				goto out;
			}
			err = dest_file->f_op->write(dest_file, pattern, strlen(pattern),
			 &dest_file->f_pos);
			if (err < 0) {
				ret = -EPERM;
				goto out;
			}
			set_fs(oldfs);
			
			sbi->db_version++;
			goto out; // skip cleanup, all went fine

/************************************************
 * remove pattern section
 ***********************************************/
		case REM:

			oldfs = get_fs();
    		set_fs(KERNEL_DS);
			
			ofp = filp_open("temp_file", O_WRONLY | O_CREAT, 0); 
			set_fs(oldfs);

			if (IS_ERR((void *)ofp)) {
			    ret = -EPERM;
			    goto out;
			}
			list_for_each_safe(pos, q, plist_head) {
			    
			    temp_node = list_entry(pos, struct pattern_item, list);
			    ret = strcmp(pattern, temp_node->pattern_data);

			    if (ret == 0) {
			    	pattern_exists = 1;
			    	list_del(pos);
			    }
			    else {
			    	strcpy(list_to_dbfile, 
			    		(const char *)temp_node->pattern_data);
					strcat(list_to_dbfile, "\n\0");

					oldfs = get_fs();
    				set_fs(KERNEL_DS);

			    	err = ofp->f_op->write(ofp, list_to_dbfile, 
			    		strlen(list_to_dbfile) , &ofp->f_pos);
					set_fs(oldfs);
					if (err < 0) {
						ret = -EPERM;
						goto cleanup;
					}	
			    }

			}

			dest_file = filp_open(sbi->pattern_db_name, O_EXCL, 0); 
			// opens existing outfile  
			if (IS_ERR((void *)dest_file)) {
				ret = -EPERM;
				goto cleanup;
			}
			ofp->f_inode->i_mode = dest_file->f_inode->i_mode;

			err = vfs_rename(ofp->f_path.dentry->d_parent->d_inode,\
			 ofp->f_path.dentry, \
			 dest_file->f_path.dentry->d_parent->d_inode, \
			 dest_file->f_path.dentry, NULL, 0);

			if (err != 0) {
				ret = -EINVAL;
				goto cleanup; // rename is part of output writing
			}

			if (pattern_exists == 0){
				ret = -EINVAL;
				goto out;
			}
		
			sbi->db_version++;

			// Coherency check in case of removal of pattern
			list_for_each_safe(iter, qq, &bad_files_list)
			{
			    bad_f_item = list_entry(iter, struct bad_file_item, list);
			    if (strcmp(bad_f_item->evicting_pattern, pattern) == 0) {
			    	//make this file good
			    	lerr = bad_f_item->bad_dentry->d_inode->i_op->setxattr 
			    	(bad_f_item->bad_dentry, STAT, "GOOD", 4, 0);
			    	if (lerr != 0) {
			    		err = -EPERM;
			    		goto out;
			    	}
			    	list_del(iter);
			    }
			}

			goto out; // skip cleanup, all went fine
			
/************************************************
 * list patterns section
 ***********************************************/
		case LIST:
			// pattern contains file path
			oldfs = get_fs();
    		set_fs(KERNEL_DS);
			
			ofp = filp_open(pattern, O_WRONLY | O_CREAT, 0); 
			set_fs(oldfs);

			if (IS_ERR((void *)ofp)) {
			    ret = -EPERM;
			    goto out;
			}
			list_for_each(pos, plist_head) {
			    
			    temp_node = list_entry(pos, struct pattern_item, list);
			    //printk("%s\n", temp_node->pattern_data);
			    
		    	strcpy(list_to_dbfile, (const char *)temp_node->pattern_data);
				strcat(list_to_dbfile, "\n\0");

				oldfs = get_fs();
				set_fs(KERNEL_DS);

		    	err = ofp->f_op->write(ofp, list_to_dbfile, 
		    		strlen(list_to_dbfile) , &ofp->f_pos);
				set_fs(oldfs);
				if (err < 0) {
					ret = -EFAULT;
					goto cleanup;
				}	
			}
			goto out;
	}

cleanup:
	err = vfs_unlink(ofp->f_path.dentry->d_parent->d_inode, 
		ofp->f_path.dentry, NULL);
	if (err != 0) {
		ret = -EINVAL;
		goto out;
	}			

out:
	if (!IS_ERR((void *)dest_file) && (dest_file != NULL)) {
		filp_close(dest_file, NULL);
	}
	if (!IS_ERR((void *)ofp) && (ofp != NULL)) {
		filp_close(ofp, NULL);
	}
	if (pattern) 
		kfree(pattern);
	if (list_to_dbfile) 
		kfree(list_to_dbfile);
	return ret;
}

#ifdef CONFIG_COMPAT

static long amfs_compat_ioctl(struct file *file, unsigned int cmd,
				unsigned long arg)
{
	long err = -ENOTTY;
	struct file *lower_file;

	lower_file = amfs_lower_file(file);

	/* XXX: use vfs_ioctl if/when VFS exports it */
	if (!lower_file || !lower_file->f_op)
		goto out;
	if (lower_file->f_op->compat_ioctl)
		err = lower_file->f_op->compat_ioctl(lower_file, cmd, arg);

out:
	return err;
}
#endif

static int amfs_mmap(struct file *file, struct vm_area_struct *vma)
{
	int err = 0;
	bool willwrite;
	struct file *lower_file;
	const struct vm_operations_struct *saved_vm_ops = NULL;

	/* this might be deferred to mmap's writepage */
	willwrite = ((vma->vm_flags | VM_SHARED | VM_WRITE) == vma->vm_flags);

	/*
	 * File systems which do not implement ->writepage may use
	 * generic_file_readonly_mmap as their ->mmap op.  If you call
	 * generic_file_readonly_mmap with VM_WRITE, you'd get an -EINVAL.
	 * But we cannot call the lower ->mmap op, so we can't tell that
	 * writeable mappings won't work.  Therefore, our only choice is to
	 * check if the lower file system supports the ->writepage, and if
	 * not, return EINVAL (the same error that
	 * generic_file_readonly_mmap returns in that case).
	 */
	lower_file = amfs_lower_file(file);
	if (willwrite && !lower_file->f_mapping->a_ops->writepage) {
		err = -EINVAL;
		printk(KERN_ERR "amfs: lower file system does not "
		       "support writeable mmap\n");
		goto out;
	}

	/*
	 * find and save lower vm_ops.
	 *
	 * XXX: the VFS should have a cleaner way of finding the lower vm_ops
	 */
	if (!AMFS_F(file)->lower_vm_ops) {
		err = lower_file->f_op->mmap(lower_file, vma);
		if (err) {
			printk(KERN_ERR "amfs: lower mmap failed %d\n", err);
			goto out;
		}
		saved_vm_ops = vma->vm_ops; /* save: came from lower ->mmap */
	}

	/*
	 * Next 3 lines are all I need from generic_file_mmap.  I definitely
	 * don't want its test for ->readpage which returns -ENOEXEC.
	 */
	file_accessed(file);
	vma->vm_ops = &amfs_vm_ops;

	file->f_mapping->a_ops = &amfs_aops; /* set our aops */
	if (!AMFS_F(file)->lower_vm_ops) /* save for our ->fault */
		AMFS_F(file)->lower_vm_ops = saved_vm_ops;

out:
	return err;
}

static int amfs_open(struct inode *inode, struct file *file)
{
	int err = 0;
	struct file *lower_file = NULL;
	struct path lower_path;

	/* don't open unhashed/deleted files */
	if (d_unhashed(file->f_path.dentry)) {
		err = -ENOENT;
		goto out_err;
	}

	file->private_data =
		kzalloc (sizeof(struct amfs_file_info), GFP_KERNEL);
	if (!AMFS_F (file)) {
		err = -ENOMEM;
		goto out_err;
	}


	/* open lower object and link amfs's file struct to lower's */
	amfs_get_lower_path(file->f_path.dentry, &lower_path);
	lower_file = dentry_open(&lower_path, file->f_flags, current_cred());
	path_put(&lower_path);
	if (IS_ERR(lower_file)) {
		err = PTR_ERR(lower_file);
		lower_file = amfs_lower_file(file);
		if (lower_file) {
			amfs_set_lower_file(file, NULL);
			fput(lower_file); /* fput calls dput for lower_dentry */
		}
	} else {
		amfs_set_lower_file(file, lower_file);
	}

	if (err)
		kfree(AMFS_F(file));
	else
		/* this is imp: If successfull, copy lower inode attributes
		 * to inode passed by upper file system
		 */
		fsstack_copy_attr_all(inode, amfs_lower_inode(inode));
out_err:
	return err;
}

static int amfs_flush(struct file *file, fl_owner_t id)
{
	int err = 0;
	struct file *lower_file = NULL;

	lower_file = amfs_lower_file(file);
	if (lower_file && lower_file->f_op && lower_file->f_op->flush) {
		filemap_write_and_wait(file->f_mapping);
		err = lower_file->f_op->flush(lower_file, id);
	}

	return err;
}

/* release all lower object references & free the file info structure */
static int amfs_file_release(struct inode *inode, struct file *file)
{
	struct file *lower_file;
	char *ATTR = NULL;
	int lerr;

	lower_file = amfs_lower_file(file);
	if (lower_file) {
		amfs_set_lower_file(file, NULL);
		fput(lower_file);
	}

	// removing all attributes
	lerr = file->f_path.dentry->d_inode->i_op-> \
	getxattr (file->f_path.dentry, STAT, ATTR, 4);
	if (lerr < 0) {
		goto out;
	}
	else {
		lerr = file->f_path.dentry->d_inode->i_op-> \
		removexattr(file->f_path.dentry, STAT);
	}

out:
	kfree(AMFS_F(file));
	return 0;
}

static int amfs_fsync(struct file *file, loff_t start, loff_t end,
			int datasync)
{
	int err;
	struct file *lower_file;
	struct path lower_path;
	struct dentry *dentry = file->f_path.dentry;

	err = __generic_file_fsync(file, start, end, datasync);
	if (err)
		goto out;
	lower_file = amfs_lower_file(file);
	amfs_get_lower_path(dentry, &lower_path);
	err = vfs_fsync_range(lower_file, start, end, datasync);
	amfs_put_lower_path(dentry, &lower_path);
out:
	return err;
}

static int amfs_fasync(int fd, struct file *file, int flag)
{
	int err = 0;
	struct file *lower_file = NULL;

	lower_file = amfs_lower_file(file);
	if (lower_file->f_op && lower_file->f_op->fasync)
		err = lower_file->f_op->fasync(fd, lower_file, flag);

	return err;
}

static ssize_t amfs_aio_read(struct kiocb *iocb, const struct iovec *iov,
			       unsigned long nr_segs, loff_t pos)
{
	int err = -EINVAL;
	struct file *file, *lower_file;

	file = iocb->ki_filp;
	lower_file = amfs_lower_file(file);
	if (!lower_file->f_op->aio_read)
		goto out;
	/*
	 * It appears safe to rewrite this iocb, because in
	 * do_io_submit@fs/aio.c, iocb is a just copy from user.
	 */
	get_file(lower_file); /* prevent lower_file from being released */
	iocb->ki_filp = lower_file;
	err = lower_file->f_op->aio_read(iocb, iov, nr_segs, pos);
	iocb->ki_filp = file;
	fput(lower_file);
	/* update upper inode atime as needed */
	if (err >= 0 || err == -EIOCBQUEUED)
		fsstack_copy_attr_atime(file->f_path.dentry->d_inode,
					file_inode(lower_file));
out:
	return err;
}

static ssize_t amfs_aio_write(struct kiocb *iocb, const struct iovec *iov,
				unsigned long nr_segs, loff_t pos)
{
	int err = -EINVAL;
	struct file *file, *lower_file;

	file = iocb->ki_filp;
	lower_file = amfs_lower_file(file);
	if (!lower_file->f_op->aio_write)
		goto out;
	/*
	 * It appears safe to rewrite this iocb, because in
	 * do_io_submit@fs/aio.c, iocb is a just copy from user.
	 */
	get_file(lower_file); /* prevent lower_file from being released */
	iocb->ki_filp = lower_file;
	err = lower_file->f_op->aio_write(iocb, iov, nr_segs, pos);
	iocb->ki_filp = file;
	fput(lower_file);
	/* update upper inode times/sizes as needed */
	if (err >= 0 || err == -EIOCBQUEUED) {
		fsstack_copy_inode_size(file->f_path.dentry->d_inode,
					file_inode(lower_file));
		fsstack_copy_attr_times(file->f_path.dentry->d_inode,
					file_inode(lower_file));
	}
out:
	return err;
}

/*
 * Wrapfs cannot use generic_file_llseek as ->llseek, because it would
 * only set the offset of the upper file.  So we have to implement our
 * own method to set both the upper and lower file offsets
 * consistently.
 */
static loff_t amfs_file_llseek(struct file *file, loff_t offset, int whence)
{
	int err;
	struct file *lower_file;

	err = generic_file_llseek(file, offset, whence);
	if (err < 0)
		goto out;

	lower_file = amfs_lower_file(file);
	err = generic_file_llseek(lower_file, offset, whence);

out:
	return err;
}

/*
 * Amfs read_iter, redirect modified iocb to lower read_iter
 */
ssize_t
amfs_read_iter(struct kiocb *iocb, struct iov_iter *iter)
{
	int err;
	struct file *file = iocb->ki_filp, *lower_file;

	lower_file = amfs_lower_file(file);
	if (!lower_file->f_op->read_iter) {
		err = -EINVAL;
		goto out;
	}

	get_file(lower_file); /* prevent lower_file from being released */
	iocb->ki_filp = lower_file;
	err = lower_file->f_op->read_iter(iocb, iter);
	iocb->ki_filp = file;
	fput(lower_file);
	/* update upper inode atime as needed */
	if (err >= 0 || err == -EIOCBQUEUED)
		fsstack_copy_attr_atime(file->f_path.dentry->d_inode,
					file_inode(lower_file));
out:
	return err;
}

/*
 * Amfs write_iter, redirect modified iocb to lower write_iter
 */
ssize_t
amfs_write_iter(struct kiocb *iocb, struct iov_iter *iter)
{
	int err;
	struct file *file = iocb->ki_filp, *lower_file;

	lower_file = amfs_lower_file(file);
	if (!lower_file->f_op->write_iter) {
		err = -EINVAL;
		goto out;
	}

	get_file(lower_file); /* prevent lower_file from being released */
	iocb->ki_filp = lower_file;
	err = lower_file->f_op->write_iter(iocb, iter);
	iocb->ki_filp = file;
	fput(lower_file);
	/* update upper inode times/sizes as needed */
	if (err >= 0 || err == -EIOCBQUEUED) {
		fsstack_copy_inode_size(file->f_path.dentry->d_inode,
					file_inode(lower_file));
		fsstack_copy_attr_times(file->f_path.dentry->d_inode,
					file_inode(lower_file));
	}
out:
	return err;
}

const struct file_operations amfs_main_fops = {
	.llseek		= generic_file_llseek,
	.read		= amfs_read,
	.write		= amfs_write,
	.unlocked_ioctl	= amfs_unlocked_ioctl,
#ifdef CONFIG_COMPAT
	.compat_ioctl	= amfs_compat_ioctl,
#endif
	.mmap		= amfs_mmap,
	.open		= amfs_open,
	.flush		= amfs_flush,
	.release	= amfs_file_release,
	.fsync		= amfs_fsync,
	.fasync		= amfs_fasync,
	.aio_read	= amfs_aio_read,
	.aio_write	= amfs_aio_write,
	.read_iter	= amfs_read_iter,
	.write_iter	= amfs_write_iter,
};

/* trimmed directory options */
const struct file_operations amfs_dir_fops = {
	.llseek		= amfs_file_llseek,
	.read		= generic_read_dir,
	.iterate	= amfs_readdir,
	.unlocked_ioctl	= amfs_unlocked_ioctl,
#ifdef CONFIG_COMPAT
	.compat_ioctl	= amfs_compat_ioctl,
#endif
	.open		= amfs_open,
	.release	= amfs_file_release,
	.flush		= amfs_flush,
	.fsync		= amfs_fsync,
	.fasync		= amfs_fasync,
};
